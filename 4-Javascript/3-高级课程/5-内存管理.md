## 1 简介 ##
类似C语言都自己的内存管理接口。而有些语言，类似JavaScript，在变量创建时分配内存，然后在它们不再使用后 "自动释放"。这称为垃圾回收。

## 2 内存生命周期 ## 
内存生命周期：
- 分配内存
- 使用内存(读、写)
- 释放内存

### 2.1 JavaScript如何分配内存的 ###
#### 2.1.1 值的初始化 #### 
为了谁，为了谁，为了程序员，JavaScript在定义变量时，就完成了内存分配
```javascript
var num = 123; //给数值变量分配内存
var str = 'abc'; // 给字符串分配内存

// 给对象及其包含的值分配内存
var obj = {
  'name': 'cat' 
}

// 给数组及其包含的值分配内存
var arr = [1, null, 'abc']

// 给函数分配内存
function f1(a){
  return a + 2;
}

// 函数表达式也能分配一个对象
oneEle.addEventListener('click', function(){
  oneEle.style.backgroundColor = 'pink';
}, false)
```

#### 2.2.2 通过函数调用的内存分配 ####
通过**函数调用**分配对象内存：
```javascript
var date = new Date(); //分配一个Date对象实例

var ele = document.createElement('div') //分配一个 DOM 元素
```

通过**方法**分配新变量或者新对象内存：
```javascript
var str = 'abc';
var newStr = str.substr(0, 3);
// newStr 是一个新的字符串变量，
// 由于字符串是不变量
// JavaScript 可能决定不分配内存，只是存储了 [0-3] 的范围


var arrBefore = ["1"];
var arrAfter = ["2"];

var newArray = arrBefore.concat(arrAfter);
```

### 3.2 值的使用 ### 
使用值的过程上实际是对分配的 内存 进行读取与写入的操作。
读取与写入可能是写入一个变量或一个对象的属性值，或者传递函数的参数

### 3.3 内存不再需要时释放 ###
内存管理的问题高发阶段，如何确认呢？
高级语言引入了"垃圾回收器"，主要跟踪内存的分配和使用，但分配的内存不再使用时，自动释放它
事实上，无法确认，只能是一个近似的过程！！！

## 4 垃圾回收 ## 
垃圾回收实现只能有限制的解决一般问题

### 4.1 引用 ### 
垃圾回收算法主要依赖于 "引用" 的概念
在内存管理的环境中，一个对象如果由访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。
例子：一个Javascript对象具有对它**原型**的引用（隐式引用）和对它**属性**的引用（显示引用）

**在这里，对象不仅指的是JavaScript对象，还包含了函数作用域和全局作用域的概念。**

### 4.2 引用计数垃圾收集 ###
最简单的垃圾收集算法。
理解：把"把对象是否不再需要"理解为"对象有没有其他对象引用到它"。如果没有引用指向该对象，那么对象将会被回收

#### 4.2.1 实例分析 #### 
```javascript
    // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
    // 很显然，没有一个可以被垃圾收集
    var o = {
      a: {
        b: 2
      }
    }
    // o2变量是第二个对"这个对象"的引用
    var o2 = o;
    // 现在，"这个对象"的原始引用o被o2替换了
    o = 1;
    // 引用"这个对象"的a属性
    var oa = o2.a;

    // 现在，"这个对象"有两个引用了，一个是o2，一个是oa
    
    
    o2 = "yo";
	/**
     * 最初的对象现在已经是零引用了
     * 可以被垃圾回收了
     * 然而它的属性a的对象还在被oa引用，所以还不能回收
     */
    /**
     * a 属性的那个对象现在也是零引用了
     * 可以被回收了
     */
    oa = null;
```

#### 4.2.2 限制：循环引用 #### 
问题：无法处理循环引用
实例：下面的例子，两个对象被创建，并相互引用，形成了一个循环。被调用之后没有离开函数作用域，所以没用了，可以被回收了。BUT，引用计数算法考虑到它们互相都有至少一次引用，所以不会被回收，惊不惊喜，意不意外
```javascript
function f(){
 var o = {};
 var o2 = {};
 o.a = o2; // o 引用 o2
 o2.a = o; // o2 引用 o

 return 'abc';
}

f();
```

### 4.3 标记-清除算法 ###
理解：把"把对象是否不再需要"理解为"对象是否可以获得"。
算法原理：假定设置一个叫做root的对象，root为全局对象。垃圾回收期**定期**从根开始找所有从根开始引用的对象，然后找这些对象引用的对。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

与上一个算法相比，因为'有零引用的对象'总是不可获得的。2012年前，所有浏览器都使用了标记-清除垃圾回收算法








