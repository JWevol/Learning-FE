JavaScript的并发模型基于"事件循环"

## 1 运行时概念 ##
JavaScript引擎着重实现和优化了以下几个方面：

### 1.1 可视化描述 ### 
![](https://i.imgur.com/WroiLkQ.png)

#### 1.1.1 栈 #### 
函数调用 形成了一个栈帧
```javascript
function foo(b) {
  var a = 10;
  return a + b + 11;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
}

console.log(bar(7));
```

- 调用bar时，创建了第一个帧，帧中包含了bar的参数和局部变量。
- bar调用foo时，第二个帧被创建，并被压到第一个帧之上，帧中包含了foo的参数和局部变量。
- 当foo返回时，最上层的帧就被弹出栈（剩下bar函数的调用帧）。
- 当bar返回时，栈就空了

#### 1.1.2 堆 ####
对象被分配在一个堆中，一堆里

#### 1.1.3 队列 #### 
- 一个JavaScript运行时包含了一个待处理的消息队列。
- 每一个消息都与一个函数相关联
- 当栈拥有足够内存时，从队列中取出一个消息进行处理

这个处理过程，包含了调用与这个消息相关联的函数，以及创建了一个初始堆栈帧。当栈再次为空的时候，也意味着消息处理结束

## 2 事件循环 ##
类似如下的方式实现：
```javascript
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

会一直等待将要到来的消息
### 2.1 执行至完成 ### 
- 每一个消息执行完成后，其它消息才会被执行
- 每当一个函数运行时，不能被抢占

该模型的缺点是在于当一个消息的完成好使过长时，网络应用无法处理交互。最好将消息拆分成几个消息

### 2.2 添加消息 ### 
- 在浏览器里，一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。
- 点击一个带有事件处理函数的元素时会被添加一个消息。

例如：调用setTimeout函数会在一个时间段过去后在队列中添加一个消息。时间段由第二个参数决定。如果队列没有其他消息，消息会立即处理，有其他消息的话，就得等待其他消息处理完。第二个参数指得是仅仅表示最少的时间，而非确定的时间

### 2.3 零延迟 ### 
- 零延迟不代表回调立即执行。
- 在零延迟调用 setTimeout 时，不是过了给定的时间间隔后就马上执行回调函数。
- 其等待的时间基于队列里正在等待的消息数量。 

### 2.4 多个运行时互相通信 ###
- 一个 web worker 或者一个跨域的 iframe 都有它们的栈、堆和消息队列
- 两个不同的运行时只有通过 postMessage 方法进行通信。该方法会给另一个运行时台南佳一个消息，如果后者监听了 message 事件

## 3 永不阻塞且绝不阻塞 ## 
事件循环 模型的特性在于：
- 永不阻塞
- 通常由事件或回调函数进行I/O处理。所以当一个引用等待 indexedDB 查询的返回或者一个XHR的请求返回时，仍然可以处理其它事情。比如用户输入
 

















 