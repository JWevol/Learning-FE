## 1 定义函数 ## 
### 1.1 函数声明 ### 
```javascript
function 函数名称(形参2，形参2) {
  语句
}
```

**注意**：
- 如果原始数据被作为**值**传递给函数，函数改变了该参数的值，这样的改变不会影响到外部或者调用函数
- 如果传递是一个对象(可以当作指针来看，传的地址)，函数改变了该对象的属性，这样的改变对函数外部可见

### 1.2 函数表达式 ### 
javascript中，函数可由函数表达创建，但这种函数是匿名函数，不一定要有函数名称。
```javascript
var 变量 = function 函数名称(形参2，形参2){
  语句
}
```

**注意**：函数名称只限在函数内部调用

### 1.3 其它方法 ###
运行时使用`Function构造器`由一个字符串创建一个函数

**注意**：当一个函数成为了一个对象的属性时，称为方法

## 2 调用函数 ## 
函数定义了，但不会自动执行它，如果你定义了函数`add`，你可以这么调用它
```javascript
add();
```

**注意**：
- 函数调用时，函数的声明尽管被提升，但要处于同一作用域中，才能正常使用。
- 函数提升仅限于function关键字声明，不适用于函数表达式

## 3 函数作用域 ## 
- 在函数内定义的变量不能在函数之外的任何地方访问，仅限函数的内部使用
- 一个函数可访问其内部定义的任何变量和函数

**一句话总结：内可以访问外，外不可以访问内**

## 4 作用域和函数堆栈 ## 
### 4.1 递归Recursion ###
一个函数可以指向并调用自身。实现的方法：
- 函数名
- arguments.callee
- 作用域下的一个指向该函数的变量名

实例：
```javascript
var foo = function bar(){
  语句
}
```

在这个函数体内，以下语句都是等价：
- `bar()`
- `arguments.callee()`
- `foo()`

诞生一个概念：调用自己的函数，称为递归函数。递归在某种意义上，近似于循环。所以必须有一个终止条件(避免无限循环或无线递归)

应用的场景：获取树结构中的所有节点，递归实现就容易的多。
将递归算法转换为非递归算法是可能的，但逻辑上更复杂，并且运用了堆栈(函数堆栈)


### 4.2 嵌套函数和闭包 ###
MDN上的原文：
![闭包原文](https://i.imgur.com/YFwmYwP.png)
如果你在一个函数里嵌套一个函数。这时候：
- 嵌套（内部）函数对其容器（外部）函数是私有的。它自身（指的是内部函数）也形成了一个闭包

闭包定义：一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）

??什么是拥有独立的环境与变量??看原文

既然嵌套函数是一个闭包，就意味着一个嵌套函数可以"继承"容器函数的参数和变量。
换句话说，内部函数包含了外部函数的作用域。

总结：
- 内部函数只可以在外部函数中访问
- 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量

### 4.2.1 函数 ###
由闭包引发的重大事件：函数柯里化
```javascript
function outside(x) {
  function inside(y) {
    return x + y;
  }

  return inside
}

fn_inside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give it
result = fn_inside(5); // returns 8

result1 = outside(3)(5); // returns 8
```
### 4.3 保存变量 ###
一个闭包必须保存可见作用域中所有参数和变量。
因为每次调用传入的参数可能不同，所以每次对外部函数的调用重新创建了一遍闭包

只有外部函数里的某些变量没被引用时，内存才被释放

### 4.4 多层嵌套函数 ###
函数可以多层嵌套。
例如，函数A包含函数B，函数B包含函数C。

分析：B和C形成了闭包。B能访问A，C能访问B和A。所以闭包可以包含多个作用域，递归式的包含了所有包含它的函数作用域。称为域链

```javascript
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // 控制台输出 6 (1 + 2 + 3)
```

分析：C可以访问B的y和A的x，原因如下：
- B形成了一个包含A的闭包，B可以访问A的参数和变量
- C形成了一个包含B的闭包
- B包含A，所以B也包含A，C可以访问B和A的参数和变量。意思是C用这个顺序链接了B和A 的作用域

### 4.5 命名冲突 ###
命名冲突：当同一个闭包作用域下两个参数或者变量同名时
解决方案：更近的作用域有更高的优先权。就近原则，这就是作用域链。

## 5 闭包 ## 
JavaScript允许函数嵌套，并且可以
- 内部函数可以访问定义在外部函数中的所有变量和函数，
- 外部函数能访问的所有变量和函数

BUT，外部函数不能后访问定义在内部函数中的变量和函数。这就给内部函数的变量提供了一定的安全性。

同时，内部函数的生存周期大于外部函数时，由于内部函数可以访问外部函数的作用域，定义在外部函数的变量和函数的生存周期就会大于外部函数本身。

当内部函数以某种方式被任何一个外部函数作用域访问时，一个闭包就产生了。

## 6 arguments对象 ## 
函数的实际参数会被保存在一个类似数组的arguments对象中。

可通过类似数组索引获取值的方法访问，从0开始

类数组对象：有一个索引编号和length属性

## 7 函数参数 ##
在ECMAScript 6中，有两个新型参数：
- 默认参数。函数参数的默认值是`undefined`
- 剩余参数。允许不确定数量的参数表示为数组

好处：使用默认参数，就无需再进行函数体内参数检查

##  8 箭头函数 ##
箭头函数：先对函数表达式具有较短的语法绑定this。并且箭头函数总是匿名的

什么情况下使用？
- 更简洁的函数
- this







